// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hikari/privacy/v1/privacy.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ECPoint represents an elliptic curve point on secp256k1.
// Both coordinates are 32-byte big-endian encoded field elements.
type ECPoint struct {
	// X coordinate (32 bytes)
	X []byte `protobuf:"bytes,1,opt,name=x,proto3" json:"x,omitempty"`
	// Y coordinate (32 bytes)
	Y []byte `protobuf:"bytes,2,opt,name=y,proto3" json:"y,omitempty"`
}

func (m *ECPoint) Reset()         { *m = ECPoint{} }
func (m *ECPoint) String() string { return proto.CompactTextString(m) }
func (*ECPoint) ProtoMessage()    {}
func (*ECPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{0}
}
func (m *ECPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ECPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ECPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ECPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECPoint.Merge(m, src)
}
func (m *ECPoint) XXX_Size() int {
	return m.Size()
}
func (m *ECPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_ECPoint.DiscardUnknown(m)
}

var xxx_messageInfo_ECPoint proto.InternalMessageInfo

func (m *ECPoint) GetX() []byte {
	if m != nil {
		return m.X
	}
	return nil
}

func (m *ECPoint) GetY() []byte {
	if m != nil {
		return m.Y
	}
	return nil
}

// OneTimeAddress represents a stealth address generated for a single payment.
// It includes the ephemeral public key (R) used in ECDH and the actual
// one-time address (P = Hs(r*V)*G + S).
type OneTimeAddress struct {
	// One-time public key derived from stealth address protocol
	Address ECPoint `protobuf:"bytes,1,opt,name=address,proto3" json:"address"`
	// Ephemeral transaction public key (R = r*G) used for ECDH
	TxPublicKey ECPoint `protobuf:"bytes,2,opt,name=tx_public_key,json=txPublicKey,proto3" json:"tx_public_key"`
}

func (m *OneTimeAddress) Reset()         { *m = OneTimeAddress{} }
func (m *OneTimeAddress) String() string { return proto.CompactTextString(m) }
func (*OneTimeAddress) ProtoMessage()    {}
func (*OneTimeAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{1}
}
func (m *OneTimeAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OneTimeAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OneTimeAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OneTimeAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OneTimeAddress.Merge(m, src)
}
func (m *OneTimeAddress) XXX_Size() int {
	return m.Size()
}
func (m *OneTimeAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_OneTimeAddress.DiscardUnknown(m)
}

var xxx_messageInfo_OneTimeAddress proto.InternalMessageInfo

func (m *OneTimeAddress) GetAddress() ECPoint {
	if m != nil {
		return m.Address
	}
	return ECPoint{}
}

func (m *OneTimeAddress) GetTxPublicKey() ECPoint {
	if m != nil {
		return m.TxPublicKey
	}
	return ECPoint{}
}

// PedersenCommitment represents a cryptographic commitment to an amount.
// C = aH + bG where 'a' is the amount and 'b' is the blinding factor.
type PedersenCommitment struct {
	// Commitment point C = aH + bG
	Commitment ECPoint `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment"`
}

func (m *PedersenCommitment) Reset()         { *m = PedersenCommitment{} }
func (m *PedersenCommitment) String() string { return proto.CompactTextString(m) }
func (*PedersenCommitment) ProtoMessage()    {}
func (*PedersenCommitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{2}
}
func (m *PedersenCommitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PedersenCommitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PedersenCommitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PedersenCommitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PedersenCommitment.Merge(m, src)
}
func (m *PedersenCommitment) XXX_Size() int {
	return m.Size()
}
func (m *PedersenCommitment) XXX_DiscardUnknown() {
	xxx_messageInfo_PedersenCommitment.DiscardUnknown(m)
}

var xxx_messageInfo_PedersenCommitment proto.InternalMessageInfo

func (m *PedersenCommitment) GetCommitment() ECPoint {
	if m != nil {
		return m.Commitment
	}
	return ECPoint{}
}

// Note represents encrypted transaction data that only the recipient can decrypt.
// It contains all information needed to claim ownership of a private deposit.
type Note struct {
	// Encrypted payload containing:
	// - amount (8 bytes)
	// - blinding factor (32 bytes)
	// - memo (variable, up to 512 bytes)
	// Total encrypted size: up to 552 bytes + 16 bytes auth tag
	EncryptedData []byte `protobuf:"bytes,1,opt,name=encrypted_data,json=encryptedData,proto3" json:"encrypted_data,omitempty"`
	// Nonce for AES-GCM encryption (12 bytes)
	Nonce []byte `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Ephemeral public key for ECDH shared secret derivation
	EphemeralKey ECPoint `protobuf:"bytes,3,opt,name=ephemeral_key,json=ephemeralKey,proto3" json:"ephemeral_key"`
}

func (m *Note) Reset()         { *m = Note{} }
func (m *Note) String() string { return proto.CompactTextString(m) }
func (*Note) ProtoMessage()    {}
func (*Note) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{3}
}
func (m *Note) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Note) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Note.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Note) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Note.Merge(m, src)
}
func (m *Note) XXX_Size() int {
	return m.Size()
}
func (m *Note) XXX_DiscardUnknown() {
	xxx_messageInfo_Note.DiscardUnknown(m)
}

var xxx_messageInfo_Note proto.InternalMessageInfo

func (m *Note) GetEncryptedData() []byte {
	if m != nil {
		return m.EncryptedData
	}
	return nil
}

func (m *Note) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Note) GetEphemeralKey() ECPoint {
	if m != nil {
		return m.EphemeralKey
	}
	return ECPoint{}
}

// PrivateDeposit represents a shielded deposit in the privacy pool.
// This is stored on-chain and visible to all observers, but the amount
// and recipient are cryptographically hidden.
type PrivateDeposit struct {
	// Denomination of the deposit (e.g., "ulight", "uphoton")
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// Global index of this deposit within its denomination pool
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// Pedersen commitment to the amount
	Commitment PedersenCommitment `protobuf:"bytes,3,opt,name=commitment,proto3" json:"commitment"`
	// One-time stealth address (recipient can scan and identify)
	OneTimeAddress OneTimeAddress `protobuf:"bytes,4,opt,name=one_time_address,json=oneTimeAddress,proto3" json:"one_time_address"`
	// Encrypted note containing amount, blinding factor, and memo
	EncryptedNote Note `protobuf:"bytes,5,opt,name=encrypted_note,json=encryptedNote,proto3" json:"encrypted_note"`
	// Nullifier hash (used to prevent double-spending)
	// In Phase 1: key image (I = x*Hp(P))
	// In Phase 2: hash-based nullifier
	Nullifier []byte `protobuf:"bytes,6,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// Block height when this deposit was created
	CreatedAtHeight int64 `protobuf:"varint,7,opt,name=created_at_height,json=createdAtHeight,proto3" json:"created_at_height,omitempty"`
	// Transaction hash that created this deposit
	TxHash string `protobuf:"bytes,8,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
}

func (m *PrivateDeposit) Reset()         { *m = PrivateDeposit{} }
func (m *PrivateDeposit) String() string { return proto.CompactTextString(m) }
func (*PrivateDeposit) ProtoMessage()    {}
func (*PrivateDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{4}
}
func (m *PrivateDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrivateDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrivateDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrivateDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrivateDeposit.Merge(m, src)
}
func (m *PrivateDeposit) XXX_Size() int {
	return m.Size()
}
func (m *PrivateDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_PrivateDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_PrivateDeposit proto.InternalMessageInfo

func (m *PrivateDeposit) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *PrivateDeposit) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PrivateDeposit) GetCommitment() PedersenCommitment {
	if m != nil {
		return m.Commitment
	}
	return PedersenCommitment{}
}

func (m *PrivateDeposit) GetOneTimeAddress() OneTimeAddress {
	if m != nil {
		return m.OneTimeAddress
	}
	return OneTimeAddress{}
}

func (m *PrivateDeposit) GetEncryptedNote() Note {
	if m != nil {
		return m.EncryptedNote
	}
	return Note{}
}

func (m *PrivateDeposit) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *PrivateDeposit) GetCreatedAtHeight() int64 {
	if m != nil {
		return m.CreatedAtHeight
	}
	return 0
}

func (m *PrivateDeposit) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// Commitment represents a balance commitment in a transaction.
// Used to prove that inputs equal outputs without revealing amounts.
type Commitment struct {
	// Pedersen commitment point
	Commitment PedersenCommitment `protobuf:"bytes,1,opt,name=commitment,proto3" json:"commitment"`
	// Range proof (Phase 2 only) - proves amount is in valid range [0, 2^64)
	// In Phase 1, this field is empty
	RangeProof []byte `protobuf:"bytes,2,opt,name=range_proof,json=rangeProof,proto3" json:"range_proof,omitempty"`
}

func (m *Commitment) Reset()         { *m = Commitment{} }
func (m *Commitment) String() string { return proto.CompactTextString(m) }
func (*Commitment) ProtoMessage()    {}
func (*Commitment) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{5}
}
func (m *Commitment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commitment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commitment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commitment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commitment.Merge(m, src)
}
func (m *Commitment) XXX_Size() int {
	return m.Size()
}
func (m *Commitment) XXX_DiscardUnknown() {
	xxx_messageInfo_Commitment.DiscardUnknown(m)
}

var xxx_messageInfo_Commitment proto.InternalMessageInfo

func (m *Commitment) GetCommitment() PedersenCommitment {
	if m != nil {
		return m.Commitment
	}
	return PedersenCommitment{}
}

func (m *Commitment) GetRangeProof() []byte {
	if m != nil {
		return m.RangeProof
	}
	return nil
}

// MerkleProof represents a proof that a commitment exists in the Merkle tree.
// Used in Phase 2 to prove deposit membership without revealing which deposit.
type MerkleProof struct {
	// Root of the Merkle tree
	Root []byte `protobuf:"bytes,1,opt,name=root,proto3" json:"root,omitempty"`
	// Leaf index (hidden in ZK proof, only used for verification)
	LeafIndex uint64 `protobuf:"varint,2,opt,name=leaf_index,json=leafIndex,proto3" json:"leaf_index,omitempty"`
	// Path from leaf to root (array of sibling hashes)
	// Length should be equal to tree depth (32 for a tree of 2^32 leaves)
	Path [][]byte `protobuf:"bytes,3,rep,name=path,proto3" json:"path,omitempty"`
}

func (m *MerkleProof) Reset()         { *m = MerkleProof{} }
func (m *MerkleProof) String() string { return proto.CompactTextString(m) }
func (*MerkleProof) ProtoMessage()    {}
func (*MerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{6}
}
func (m *MerkleProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MerkleProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MerkleProof.Merge(m, src)
}
func (m *MerkleProof) XXX_Size() int {
	return m.Size()
}
func (m *MerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_MerkleProof proto.InternalMessageInfo

func (m *MerkleProof) GetRoot() []byte {
	if m != nil {
		return m.Root
	}
	return nil
}

func (m *MerkleProof) GetLeafIndex() uint64 {
	if m != nil {
		return m.LeafIndex
	}
	return 0
}

func (m *MerkleProof) GetPath() [][]byte {
	if m != nil {
		return m.Path
	}
	return nil
}

// ZKProof represents a zero-knowledge proof for Phase 2 operations.
// The proof system can be Groth16 or PLONK.
type ZKProof struct {
	// Serialized proof bytes (format depends on proof system)
	// Groth16: ~128-256 bytes
	// PLONK: ~512-768 bytes
	Proof []byte `protobuf:"bytes,1,opt,name=proof,proto3" json:"proof,omitempty"`
	// Public inputs to the circuit
	PublicInputs [][]byte `protobuf:"bytes,2,rep,name=public_inputs,json=publicInputs,proto3" json:"public_inputs,omitempty"`
	// Proof system identifier ("groth16" or "plonk")
	ProofSystem string `protobuf:"bytes,3,opt,name=proof_system,json=proofSystem,proto3" json:"proof_system,omitempty"`
}

func (m *ZKProof) Reset()         { *m = ZKProof{} }
func (m *ZKProof) String() string { return proto.CompactTextString(m) }
func (*ZKProof) ProtoMessage()    {}
func (*ZKProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{7}
}
func (m *ZKProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ZKProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ZKProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ZKProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ZKProof.Merge(m, src)
}
func (m *ZKProof) XXX_Size() int {
	return m.Size()
}
func (m *ZKProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ZKProof.DiscardUnknown(m)
}

var xxx_messageInfo_ZKProof proto.InternalMessageInfo

func (m *ZKProof) GetProof() []byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

func (m *ZKProof) GetPublicInputs() [][]byte {
	if m != nil {
		return m.PublicInputs
	}
	return nil
}

func (m *ZKProof) GetProofSystem() string {
	if m != nil {
		return m.ProofSystem
	}
	return ""
}

// TransferInput represents an input to a private transfer.
type TransferInput struct {
	// Nullifier to mark this input as spent
	Nullifier []byte `protobuf:"bytes,1,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// For Phase 1: deposit index (visible on-chain)
	// For Phase 2: hidden in ZK proof
	DepositIndex uint64 `protobuf:"varint,2,opt,name=deposit_index,json=depositIndex,proto3" json:"deposit_index,omitempty"`
	// Signature proving ownership (Phase 1 only)
	// In Phase 2, ownership is proven via ZK proof
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *TransferInput) Reset()         { *m = TransferInput{} }
func (m *TransferInput) String() string { return proto.CompactTextString(m) }
func (*TransferInput) ProtoMessage()    {}
func (*TransferInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{8}
}
func (m *TransferInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferInput.Merge(m, src)
}
func (m *TransferInput) XXX_Size() int {
	return m.Size()
}
func (m *TransferInput) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferInput.DiscardUnknown(m)
}

var xxx_messageInfo_TransferInput proto.InternalMessageInfo

func (m *TransferInput) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *TransferInput) GetDepositIndex() uint64 {
	if m != nil {
		return m.DepositIndex
	}
	return 0
}

func (m *TransferInput) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// TransferOutput represents an output of a private transfer.
type TransferOutput struct {
	// Denomination (must match input denomination)
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// Pedersen commitment to output amount
	Commitment PedersenCommitment `protobuf:"bytes,2,opt,name=commitment,proto3" json:"commitment"`
	// One-time address for the recipient
	OneTimeAddress OneTimeAddress `protobuf:"bytes,3,opt,name=one_time_address,json=oneTimeAddress,proto3" json:"one_time_address"`
	// Encrypted note for the recipient
	EncryptedNote Note `protobuf:"bytes,4,opt,name=encrypted_note,json=encryptedNote,proto3" json:"encrypted_note"`
}

func (m *TransferOutput) Reset()         { *m = TransferOutput{} }
func (m *TransferOutput) String() string { return proto.CompactTextString(m) }
func (*TransferOutput) ProtoMessage()    {}
func (*TransferOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{9}
}
func (m *TransferOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferOutput.Merge(m, src)
}
func (m *TransferOutput) XXX_Size() int {
	return m.Size()
}
func (m *TransferOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferOutput.DiscardUnknown(m)
}

var xxx_messageInfo_TransferOutput proto.InternalMessageInfo

func (m *TransferOutput) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *TransferOutput) GetCommitment() PedersenCommitment {
	if m != nil {
		return m.Commitment
	}
	return PedersenCommitment{}
}

func (m *TransferOutput) GetOneTimeAddress() OneTimeAddress {
	if m != nil {
		return m.OneTimeAddress
	}
	return OneTimeAddress{}
}

func (m *TransferOutput) GetEncryptedNote() Note {
	if m != nil {
		return m.EncryptedNote
	}
	return Note{}
}

// ViewKey represents a user's view key pair for scanning deposits.
type ViewKey struct {
	// Private view key (32 bytes scalar)
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Public view key (EC point)
	PublicKey ECPoint `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key"`
}

func (m *ViewKey) Reset()         { *m = ViewKey{} }
func (m *ViewKey) String() string { return proto.CompactTextString(m) }
func (*ViewKey) ProtoMessage()    {}
func (*ViewKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{10}
}
func (m *ViewKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewKey.Merge(m, src)
}
func (m *ViewKey) XXX_Size() int {
	return m.Size()
}
func (m *ViewKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewKey.DiscardUnknown(m)
}

var xxx_messageInfo_ViewKey proto.InternalMessageInfo

func (m *ViewKey) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *ViewKey) GetPublicKey() ECPoint {
	if m != nil {
		return m.PublicKey
	}
	return ECPoint{}
}

// SpendKey represents a user's spend key pair for spending deposits.
type SpendKey struct {
	// Private spend key (32 bytes scalar)
	PrivateKey []byte `protobuf:"bytes,1,opt,name=private_key,json=privateKey,proto3" json:"private_key,omitempty"`
	// Public spend key (EC point)
	PublicKey ECPoint `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key"`
}

func (m *SpendKey) Reset()         { *m = SpendKey{} }
func (m *SpendKey) String() string { return proto.CompactTextString(m) }
func (*SpendKey) ProtoMessage()    {}
func (*SpendKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{11}
}
func (m *SpendKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpendKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpendKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpendKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpendKey.Merge(m, src)
}
func (m *SpendKey) XXX_Size() int {
	return m.Size()
}
func (m *SpendKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SpendKey.DiscardUnknown(m)
}

var xxx_messageInfo_SpendKey proto.InternalMessageInfo

func (m *SpendKey) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *SpendKey) GetPublicKey() ECPoint {
	if m != nil {
		return m.PublicKey
	}
	return ECPoint{}
}

// KeyPair combines view and spend keys for a user.
type KeyPair struct {
	ViewKey  ViewKey  `protobuf:"bytes,1,opt,name=view_key,json=viewKey,proto3" json:"view_key"`
	SpendKey SpendKey `protobuf:"bytes,2,opt,name=spend_key,json=spendKey,proto3" json:"spend_key"`
}

func (m *KeyPair) Reset()         { *m = KeyPair{} }
func (m *KeyPair) String() string { return proto.CompactTextString(m) }
func (*KeyPair) ProtoMessage()    {}
func (*KeyPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_645426320d3ba953, []int{12}
}
func (m *KeyPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyPair.Merge(m, src)
}
func (m *KeyPair) XXX_Size() int {
	return m.Size()
}
func (m *KeyPair) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyPair.DiscardUnknown(m)
}

var xxx_messageInfo_KeyPair proto.InternalMessageInfo

func (m *KeyPair) GetViewKey() ViewKey {
	if m != nil {
		return m.ViewKey
	}
	return ViewKey{}
}

func (m *KeyPair) GetSpendKey() SpendKey {
	if m != nil {
		return m.SpendKey
	}
	return SpendKey{}
}

func init() {
	proto.RegisterType((*ECPoint)(nil), "hikari.privacy.v1.ECPoint")
	proto.RegisterType((*OneTimeAddress)(nil), "hikari.privacy.v1.OneTimeAddress")
	proto.RegisterType((*PedersenCommitment)(nil), "hikari.privacy.v1.PedersenCommitment")
	proto.RegisterType((*Note)(nil), "hikari.privacy.v1.Note")
	proto.RegisterType((*PrivateDeposit)(nil), "hikari.privacy.v1.PrivateDeposit")
	proto.RegisterType((*Commitment)(nil), "hikari.privacy.v1.Commitment")
	proto.RegisterType((*MerkleProof)(nil), "hikari.privacy.v1.MerkleProof")
	proto.RegisterType((*ZKProof)(nil), "hikari.privacy.v1.ZKProof")
	proto.RegisterType((*TransferInput)(nil), "hikari.privacy.v1.TransferInput")
	proto.RegisterType((*TransferOutput)(nil), "hikari.privacy.v1.TransferOutput")
	proto.RegisterType((*ViewKey)(nil), "hikari.privacy.v1.ViewKey")
	proto.RegisterType((*SpendKey)(nil), "hikari.privacy.v1.SpendKey")
	proto.RegisterType((*KeyPair)(nil), "hikari.privacy.v1.KeyPair")
}

func init() { proto.RegisterFile("hikari/privacy/v1/privacy.proto", fileDescriptor_645426320d3ba953) }

var fileDescriptor_645426320d3ba953 = []byte{
	// 824 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcf, 0x6f, 0x1b, 0x45,
	0x14, 0xce, 0xc6, 0x4e, 0x1c, 0x3f, 0xff, 0x80, 0x8c, 0x22, 0xd5, 0x84, 0xe2, 0xa4, 0x5b, 0x45,
	0xaa, 0x90, 0x6a, 0xab, 0xc0, 0x09, 0x24, 0xa0, 0x24, 0x95, 0x52, 0x59, 0xb4, 0xc6, 0x8d, 0x7a,
	0xe8, 0x65, 0x35, 0xd9, 0x7d, 0xf1, 0x8e, 0xec, 0x9d, 0x59, 0xcd, 0x8c, 0xdd, 0x5d, 0xee, 0x70,
	0x40, 0x1c, 0x10, 0x7f, 0x55, 0x8f, 0x3d, 0x72, 0x42, 0x28, 0xf9, 0x47, 0xd0, 0xcc, 0xec, 0x3a,
	0x36, 0xf1, 0x21, 0x54, 0x55, 0x2f, 0xd6, 0xbc, 0xcf, 0xef, 0x7d, 0xef, 0xcd, 0x7b, 0xdf, 0x9b,
	0x85, 0x83, 0x98, 0x4d, 0xa8, 0x64, 0xfd, 0x54, 0xb2, 0x39, 0x0d, 0xf3, 0xfe, 0xfc, 0x51, 0x79,
	0xec, 0xa5, 0x52, 0x68, 0x41, 0x76, 0x9d, 0x43, 0xaf, 0x44, 0xe7, 0x8f, 0xf6, 0x3f, 0x09, 0x85,
	0x4a, 0x84, 0x0a, 0xac, 0x43, 0xdf, 0x19, 0xce, 0x7b, 0x7f, 0x6f, 0x2c, 0xc6, 0xc2, 0xe1, 0xe6,
	0x54, 0xa0, 0xbb, 0x34, 0x61, 0x5c, 0xf4, 0xed, 0xaf, 0x83, 0xfc, 0x23, 0xa8, 0x3d, 0x39, 0x1e,
	0x0a, 0xc6, 0x35, 0x69, 0x82, 0x97, 0x75, 0xbc, 0x43, 0xef, 0x41, 0x73, 0xe4, 0x65, 0xc6, 0xca,
	0x3b, 0x9b, 0xce, 0xca, 0xfd, 0x3f, 0x3d, 0x68, 0x3f, 0xe7, 0x78, 0xc6, 0x12, 0x7c, 0x1c, 0x45,
	0x12, 0x95, 0x22, 0x5f, 0x43, 0x8d, 0xba, 0xa3, 0x0d, 0x6a, 0x7c, 0xb1, 0xdf, 0xbb, 0x51, 0x62,
	0xaf, 0xe0, 0xfe, 0xa1, 0xfa, 0xe6, 0xef, 0x83, 0x8d, 0x51, 0x19, 0x40, 0x4e, 0xa0, 0xa5, 0xb3,
	0x20, 0x9d, 0x9d, 0x4f, 0x59, 0x18, 0x4c, 0xd0, 0x25, 0xba, 0x0d, 0x43, 0x43, 0x67, 0x43, 0x1b,
	0x35, 0xc0, 0xdc, 0x7f, 0x09, 0x64, 0x88, 0x11, 0x4a, 0x85, 0xfc, 0x58, 0x24, 0x09, 0xd3, 0x09,
	0x72, 0x4d, 0xbe, 0x07, 0x08, 0x17, 0xd6, 0xad, 0x4b, 0x5b, 0x8a, 0xf1, 0x7f, 0xf3, 0xa0, 0xfa,
	0x4c, 0x68, 0x24, 0x47, 0xd0, 0x46, 0x1e, 0xca, 0x3c, 0xd5, 0x18, 0x05, 0x11, 0xd5, 0xb4, 0x68,
	0x4f, 0x6b, 0x81, 0x9e, 0x50, 0x4d, 0xc9, 0x1e, 0x6c, 0x71, 0xc1, 0x43, 0x2c, 0xda, 0xe5, 0x0c,
	0xf2, 0x04, 0x5a, 0x98, 0xc6, 0x98, 0xa0, 0xa4, 0x53, 0x7b, 0xc7, 0xca, 0x2d, 0x4b, 0x69, 0x2e,
	0xc2, 0xcc, 0x25, 0x7f, 0xa9, 0x40, 0x7b, 0x68, 0x5c, 0x35, 0x9e, 0x60, 0x2a, 0x14, 0xd3, 0x26,
	0x5f, 0x84, 0x5c, 0x24, 0xb6, 0x9a, 0xfa, 0xc8, 0x19, 0x06, 0x65, 0x3c, 0xc2, 0xcc, 0x56, 0x51,
	0x1d, 0x39, 0x83, 0x0c, 0x56, 0xba, 0xe1, 0x4a, 0x38, 0x5a, 0x53, 0xc2, 0xcd, 0x46, 0xde, 0x6c,
	0x0c, 0xf9, 0x09, 0x3e, 0x16, 0x1c, 0x03, 0xcd, 0x12, 0x0c, 0xca, 0xd9, 0x57, 0x2d, 0xe5, 0xbd,
	0x35, 0x94, 0xab, 0x7a, 0x29, 0xe8, 0xda, 0x62, 0x55, 0x45, 0x27, 0xcb, 0x2d, 0xe6, 0x42, 0x63,
	0x67, 0xcb, 0x12, 0xde, 0x59, 0x43, 0x68, 0x66, 0x52, 0xd0, 0x5c, 0x4f, 0xc0, 0x0e, 0xea, 0x2e,
	0xd4, 0xf9, 0x6c, 0x3a, 0x65, 0x17, 0x0c, 0x65, 0x67, 0xdb, 0x4e, 0xe1, 0x1a, 0x20, 0x9f, 0xc3,
	0x6e, 0x28, 0x91, 0x9a, 0x0c, 0x54, 0x07, 0x31, 0xb2, 0x71, 0xac, 0x3b, 0xb5, 0x43, 0xef, 0x41,
	0x65, 0xf4, 0x51, 0xf1, 0xc7, 0x63, 0x7d, 0x6a, 0x61, 0x72, 0x07, 0x6a, 0x3a, 0x0b, 0x62, 0xaa,
	0xe2, 0xce, 0x8e, 0xed, 0xee, 0xb6, 0xce, 0x4e, 0xa9, 0x8a, 0xfd, 0x9f, 0x01, 0x96, 0x44, 0x36,
	0x58, 0x23, 0xb2, 0x77, 0x6e, 0xeb, 0x01, 0x34, 0x24, 0xe5, 0x63, 0x34, 0x8b, 0x2c, 0x2e, 0x0a,
	0x15, 0x81, 0x85, 0x86, 0x06, 0xf1, 0xcf, 0xa0, 0xf1, 0x23, 0xca, 0xc9, 0xd4, 0x99, 0x84, 0x40,
	0x55, 0x0a, 0xa1, 0x0b, 0x31, 0xda, 0x33, 0xf9, 0x0c, 0x60, 0x8a, 0xf4, 0x22, 0x58, 0x96, 0x40,
	0xdd, 0x20, 0x4f, 0xad, 0x0c, 0x08, 0x54, 0x53, 0xaa, 0xe3, 0x4e, 0xe5, 0xb0, 0x62, 0x42, 0xcc,
	0xd9, 0x1f, 0x43, 0xed, 0xd5, 0xc0, 0x31, 0xee, 0xc1, 0x96, 0xcb, 0xed, 0x28, 0x9d, 0x41, 0xee,
	0x43, 0xab, 0x58, 0x51, 0xc6, 0xd3, 0x99, 0x56, 0x9d, 0x4d, 0x1b, 0xdd, 0x74, 0xe0, 0x53, 0x8b,
	0x91, 0x7b, 0xd0, 0xb4, 0xde, 0x81, 0xca, 0x95, 0xc6, 0xc4, 0x4a, 0xac, 0x3e, 0x6a, 0x58, 0xec,
	0x85, 0x85, 0xfc, 0x14, 0x5a, 0x67, 0x92, 0x72, 0x75, 0x81, 0xd2, 0x06, 0xad, 0x8e, 0xcb, 0xfb,
	0xef, 0xb8, 0xee, 0x43, 0x2b, 0x72, 0x4a, 0x5f, 0xb9, 0x4d, 0xb3, 0x00, 0xdd, 0x85, 0xee, 0x42,
	0x5d, 0xb1, 0x31, 0xa7, 0x7a, 0x26, 0xd1, 0xe6, 0x6c, 0x8e, 0xae, 0x01, 0xff, 0xf7, 0x4d, 0x68,
	0x97, 0x29, 0x9f, 0xcf, 0xb4, 0xc9, 0xb9, 0x7e, 0x69, 0x56, 0xe7, 0xb8, 0xf9, 0xfe, 0xd7, 0xa3,
	0xf2, 0xbe, 0xd7, 0xa3, 0xfa, 0xff, 0xd7, 0xc3, 0x9f, 0x40, 0xed, 0x25, 0xc3, 0xd7, 0x03, 0xcc,
	0x8d, 0xd6, 0x52, 0xf7, 0x9a, 0xd8, 0x37, 0xc9, 0x35, 0x1f, 0x0a, 0xc8, 0x38, 0x7c, 0x07, 0xf0,
	0x0e, 0xef, 0x72, 0x3d, 0x5d, 0xbc, 0xca, 0x53, 0xd8, 0x79, 0x91, 0x22, 0x8f, 0x3e, 0x4c, 0xb6,
	0x5f, 0x3d, 0xa8, 0x0d, 0x30, 0x1f, 0x52, 0x26, 0xc9, 0x37, 0xb0, 0x33, 0x67, 0xf8, 0x7a, 0x91,
	0x6a, 0x3d, 0x55, 0xd1, 0x89, 0xf2, 0x93, 0x34, 0x2f, 0x1a, 0xf3, 0x2d, 0xd4, 0x95, 0x29, 0x7b,
	0xa9, 0x90, 0x4f, 0xd7, 0x44, 0x97, 0x57, 0x2b, 0xc2, 0x77, 0x54, 0x69, 0x3f, 0x7b, 0x73, 0xd9,
	0xf5, 0xde, 0x5e, 0x76, 0xbd, 0x7f, 0x2e, 0xbb, 0xde, 0x1f, 0x57, 0xdd, 0x8d, 0xb7, 0x57, 0xdd,
	0x8d, 0xbf, 0xae, 0xba, 0x1b, 0xaf, 0xbe, 0x1a, 0x33, 0x1d, 0xcf, 0xce, 0x7b, 0xa1, 0x48, 0xfa,
	0xa7, 0x96, 0xf0, 0xe1, 0x71, 0x4c, 0x19, 0xef, 0x3b, 0xf6, 0x87, 0xa1, 0x35, 0xb2, 0xc5, 0xa7,
	0x5f, 0xe7, 0x29, 0xaa, 0xf3, 0x6d, 0xfb, 0x7d, 0xfe, 0xf2, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xdf, 0x43, 0xdb, 0xe6, 0x19, 0x08, 0x00, 0x00,
}

func (m *ECPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ECPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ECPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Y) > 0 {
		i -= len(m.Y)
		copy(dAtA[i:], m.Y)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Y)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.X) > 0 {
		i -= len(m.X)
		copy(dAtA[i:], m.X)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.X)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OneTimeAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OneTimeAddress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OneTimeAddress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TxPublicKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PedersenCommitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PedersenCommitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PedersenCommitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Note) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Note) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Note) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EphemeralKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EncryptedData) > 0 {
		i -= len(m.EncryptedData)
		copy(dAtA[i:], m.EncryptedData)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.EncryptedData)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrivateDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrivateDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrivateDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAtHeight != 0 {
		i = encodeVarintPrivacy(dAtA, i, uint64(m.CreatedAtHeight))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.EncryptedNote.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.OneTimeAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Index != 0 {
		i = encodeVarintPrivacy(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Commitment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commitment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commitment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RangeProof) > 0 {
		i -= len(m.RangeProof)
		copy(dAtA[i:], m.RangeProof)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.RangeProof)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MerkleProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MerkleProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MerkleProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		for iNdEx := len(m.Path) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Path[iNdEx])
			copy(dAtA[i:], m.Path[iNdEx])
			i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Path[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.LeafIndex != 0 {
		i = encodeVarintPrivacy(dAtA, i, uint64(m.LeafIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Root) > 0 {
		i -= len(m.Root)
		copy(dAtA[i:], m.Root)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Root)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ZKProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZKProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ZKProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProofSystem) > 0 {
		i -= len(m.ProofSystem)
		copy(dAtA[i:], m.ProofSystem)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.ProofSystem)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PublicInputs) > 0 {
		for iNdEx := len(m.PublicInputs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicInputs[iNdEx])
			copy(dAtA[i:], m.PublicInputs[iNdEx])
			i = encodeVarintPrivacy(dAtA, i, uint64(len(m.PublicInputs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Proof) > 0 {
		i -= len(m.Proof)
		copy(dAtA[i:], m.Proof)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Proof)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositIndex != 0 {
		i = encodeVarintPrivacy(dAtA, i, uint64(m.DepositIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferOutput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferOutput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EncryptedNote.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.OneTimeAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SpendKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpendKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SpendKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PublicKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.PrivateKey) > 0 {
		i -= len(m.PrivateKey)
		copy(dAtA[i:], m.PrivateKey)
		i = encodeVarintPrivacy(dAtA, i, uint64(len(m.PrivateKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SpendKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.ViewKey.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintPrivacy(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintPrivacy(dAtA []byte, offset int, v uint64) int {
	offset -= sovPrivacy(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ECPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.X)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = len(m.Y)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	return n
}

func (m *OneTimeAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Address.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.TxPublicKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *PedersenCommitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Commitment.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *Note) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EncryptedData)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = m.EphemeralKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *PrivateDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovPrivacy(uint64(m.Index))
	}
	l = m.Commitment.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.OneTimeAddress.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.EncryptedNote.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	if m.CreatedAtHeight != 0 {
		n += 1 + sovPrivacy(uint64(m.CreatedAtHeight))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	return n
}

func (m *Commitment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Commitment.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = len(m.RangeProof)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	return n
}

func (m *MerkleProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	if m.LeafIndex != 0 {
		n += 1 + sovPrivacy(uint64(m.LeafIndex))
	}
	if len(m.Path) > 0 {
		for _, b := range m.Path {
			l = len(b)
			n += 1 + l + sovPrivacy(uint64(l))
		}
	}
	return n
}

func (m *ZKProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proof)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	if len(m.PublicInputs) > 0 {
		for _, b := range m.PublicInputs {
			l = len(b)
			n += 1 + l + sovPrivacy(uint64(l))
		}
	}
	l = len(m.ProofSystem)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	return n
}

func (m *TransferInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	if m.DepositIndex != 0 {
		n += 1 + sovPrivacy(uint64(m.DepositIndex))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	return n
}

func (m *TransferOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = m.Commitment.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.OneTimeAddress.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.EncryptedNote.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *ViewKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = m.PublicKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *SpendKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrivateKey)
	if l > 0 {
		n += 1 + l + sovPrivacy(uint64(l))
	}
	l = m.PublicKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func (m *KeyPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.ViewKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	l = m.SpendKey.Size()
	n += 1 + l + sovPrivacy(uint64(l))
	return n
}

func sovPrivacy(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPrivacy(x uint64) (n int) {
	return sovPrivacy(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ECPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ECPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ECPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.X = append(m.X[:0], dAtA[iNdEx:postIndex]...)
			if m.X == nil {
				m.X = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Y = append(m.Y[:0], dAtA[iNdEx:postIndex]...)
			if m.Y == nil {
				m.Y = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OneTimeAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OneTimeAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OneTimeAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxPublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxPublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PedersenCommitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PedersenCommitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PedersenCommitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Note) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Note: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Note: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedData = append(m.EncryptedData[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedData == nil {
				m.EncryptedData = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EphemeralKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EphemeralKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrivateDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrivateDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrivateDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OneTimeAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncryptedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAtHeight", wireType)
			}
			m.CreatedAtHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAtHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commitment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commitment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commitment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangeProof = append(m.RangeProof[:0], dAtA[iNdEx:postIndex]...)
			if m.RangeProof == nil {
				m.RangeProof = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MerkleProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MerkleProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MerkleProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root[:0], dAtA[iNdEx:postIndex]...)
			if m.Root == nil {
				m.Root = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafIndex", wireType)
			}
			m.LeafIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeafIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, make([]byte, postIndex-iNdEx))
			copy(m.Path[len(m.Path)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZKProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZKProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZKProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proof = append(m.Proof[:0], dAtA[iNdEx:postIndex]...)
			if m.Proof == nil {
				m.Proof = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicInputs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicInputs = append(m.PublicInputs, make([]byte, postIndex-iNdEx))
			copy(m.PublicInputs[len(m.PublicInputs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofSystem = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositIndex", wireType)
			}
			m.DepositIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OneTimeAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncryptedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpendKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpendKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpendKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateKey = append(m.PrivateKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PrivateKey == nil {
				m.PrivateKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PublicKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ViewKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpendKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrivacy
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrivacy
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SpendKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrivacy(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrivacy
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrivacy(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrivacy
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrivacy
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPrivacy
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPrivacy
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPrivacy
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPrivacy        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrivacy          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPrivacy = fmt.Errorf("proto: unexpected end of group")
)
