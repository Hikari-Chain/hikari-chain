// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: hikari/privacy/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgShield defines a message for shielding (depositing) coins into the privacy pool.
// The sender's public coins are burned and a new private deposit is created.
type MsgShield struct {
	// Sender's address (must have sufficient public balance)
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Amount to shield (e.g., "100ulight")
	Amount types.Coin `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount"`
	// One-time address for this deposit
	OneTimeAddress OneTimeAddress `protobuf:"bytes,3,opt,name=one_time_address,json=oneTimeAddress,proto3" json:"one_time_address"`
	// Pedersen commitment to the amount
	Commitment PedersenCommitment `protobuf:"bytes,4,opt,name=commitment,proto3" json:"commitment"`
	// Encrypted note for the recipient
	EncryptedNote Note `protobuf:"bytes,5,opt,name=encrypted_note,json=encryptedNote,proto3" json:"encrypted_note"`
}

func (m *MsgShield) Reset()         { *m = MsgShield{} }
func (m *MsgShield) String() string { return proto.CompactTextString(m) }
func (*MsgShield) ProtoMessage()    {}
func (*MsgShield) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{0}
}
func (m *MsgShield) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgShield) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgShield.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgShield) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgShield.Merge(m, src)
}
func (m *MsgShield) XXX_Size() int {
	return m.Size()
}
func (m *MsgShield) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgShield.DiscardUnknown(m)
}

var xxx_messageInfo_MsgShield proto.InternalMessageInfo

func (m *MsgShield) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgShield) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

func (m *MsgShield) GetOneTimeAddress() OneTimeAddress {
	if m != nil {
		return m.OneTimeAddress
	}
	return OneTimeAddress{}
}

func (m *MsgShield) GetCommitment() PedersenCommitment {
	if m != nil {
		return m.Commitment
	}
	return PedersenCommitment{}
}

func (m *MsgShield) GetEncryptedNote() Note {
	if m != nil {
		return m.EncryptedNote
	}
	return Note{}
}

// MsgShieldResponse returns the deposit index assigned to the new private deposit.
type MsgShieldResponse struct {
	// Denomination of the shielded deposit
	Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`
	// Index assigned to the new deposit within its denomination pool
	DepositIndex uint64 `protobuf:"varint,2,opt,name=deposit_index,json=depositIndex,proto3" json:"deposit_index,omitempty"`
	// Merkle tree root after insertion (Phase 2 only)
	MerkleRoot []byte `protobuf:"bytes,3,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
}

func (m *MsgShieldResponse) Reset()         { *m = MsgShieldResponse{} }
func (m *MsgShieldResponse) String() string { return proto.CompactTextString(m) }
func (*MsgShieldResponse) ProtoMessage()    {}
func (*MsgShieldResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{1}
}
func (m *MsgShieldResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgShieldResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgShieldResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgShieldResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgShieldResponse.Merge(m, src)
}
func (m *MsgShieldResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgShieldResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgShieldResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgShieldResponse proto.InternalMessageInfo

func (m *MsgShieldResponse) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgShieldResponse) GetDepositIndex() uint64 {
	if m != nil {
		return m.DepositIndex
	}
	return 0
}

func (m *MsgShieldResponse) GetMerkleRoot() []byte {
	if m != nil {
		return m.MerkleRoot
	}
	return nil
}

// MsgPrivateTransfer defines a message for transferring coins within the privacy pool.
// Phase 1: Uses simple signatures, deposit indices are visible.
// Phase 2: Uses ZK proofs, transaction graph is completely hidden.
type MsgPrivateTransfer struct {
	// Sender's address (only for signature verification, not linked to deposits)
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Denomination being transferred (e.g., "ulight")
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// Inputs to spend (1-16 inputs)
	Inputs []TransferInput `protobuf:"bytes,3,rep,name=inputs,proto3" json:"inputs"`
	// Outputs to create (1-16 outputs)
	Outputs []TransferOutput `protobuf:"bytes,4,rep,name=outputs,proto3" json:"outputs"`
	// Phase 1: Empty (uses signatures in TransferInput)
	// Phase 2: ZK proof that:
	//   - All inputs are in the Merkle tree
	//   - Nullifiers are correctly derived
	//   - Sum(input amounts) = Sum(output amounts)
	//   - All commitments are well-formed
	ZkProof *ZKProof `protobuf:"bytes,5,opt,name=zk_proof,json=zkProof,proto3" json:"zk_proof,omitempty"`
	// Commitment balance proof (proves inputs = outputs)
	// C_total = Sum(C_inputs) - Sum(C_outputs) = 0*H + b*G
	// Where 'b' is the difference in blinding factors
	BalanceCommitment PedersenCommitment `protobuf:"bytes,6,opt,name=balance_commitment,json=balanceCommitment,proto3" json:"balance_commitment"`
	// Fee paid for this transaction (from public balance or included in private balance)
	// For simplicity in Phase 1, fee is paid from sender's public balance
	Fee types.Coin `protobuf:"bytes,7,opt,name=fee,proto3" json:"fee"`
}

func (m *MsgPrivateTransfer) Reset()         { *m = MsgPrivateTransfer{} }
func (m *MsgPrivateTransfer) String() string { return proto.CompactTextString(m) }
func (*MsgPrivateTransfer) ProtoMessage()    {}
func (*MsgPrivateTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{2}
}
func (m *MsgPrivateTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPrivateTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPrivateTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPrivateTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPrivateTransfer.Merge(m, src)
}
func (m *MsgPrivateTransfer) XXX_Size() int {
	return m.Size()
}
func (m *MsgPrivateTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPrivateTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPrivateTransfer proto.InternalMessageInfo

func (m *MsgPrivateTransfer) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgPrivateTransfer) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgPrivateTransfer) GetInputs() []TransferInput {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *MsgPrivateTransfer) GetOutputs() []TransferOutput {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *MsgPrivateTransfer) GetZkProof() *ZKProof {
	if m != nil {
		return m.ZkProof
	}
	return nil
}

func (m *MsgPrivateTransfer) GetBalanceCommitment() PedersenCommitment {
	if m != nil {
		return m.BalanceCommitment
	}
	return PedersenCommitment{}
}

func (m *MsgPrivateTransfer) GetFee() types.Coin {
	if m != nil {
		return m.Fee
	}
	return types.Coin{}
}

// MsgPrivateTransferResponse returns the indices of newly created outputs.
type MsgPrivateTransferResponse struct {
	// Indices assigned to the new output deposits
	OutputIndices []uint64 `protobuf:"varint,1,rep,packed,name=output_indices,json=outputIndices,proto3" json:"output_indices,omitempty"`
	// Merkle tree root after insertion (Phase 2 only)
	MerkleRoot []byte `protobuf:"bytes,2,opt,name=merkle_root,json=merkleRoot,proto3" json:"merkle_root,omitempty"`
}

func (m *MsgPrivateTransferResponse) Reset()         { *m = MsgPrivateTransferResponse{} }
func (m *MsgPrivateTransferResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPrivateTransferResponse) ProtoMessage()    {}
func (*MsgPrivateTransferResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{3}
}
func (m *MsgPrivateTransferResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPrivateTransferResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPrivateTransferResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPrivateTransferResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPrivateTransferResponse.Merge(m, src)
}
func (m *MsgPrivateTransferResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPrivateTransferResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPrivateTransferResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPrivateTransferResponse proto.InternalMessageInfo

func (m *MsgPrivateTransferResponse) GetOutputIndices() []uint64 {
	if m != nil {
		return m.OutputIndices
	}
	return nil
}

func (m *MsgPrivateTransferResponse) GetMerkleRoot() []byte {
	if m != nil {
		return m.MerkleRoot
	}
	return nil
}

// MsgUnshield defines a message for unshielding (withdrawing) coins from the privacy pool.
// The private deposit is spent and public coins are minted to the recipient.
type MsgUnshield struct {
	// Sender's address (receives the unshielded coins)
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	// Denomination to unshield (e.g., "ulight")
	Denom string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	// Recipient address for the unshielded coins
	// Can be the same as sender or different
	Recipient string `protobuf:"bytes,3,opt,name=recipient,proto3" json:"recipient,omitempty"`
	// Amount to unshield
	Amount string `protobuf:"bytes,4,opt,name=amount,proto3" json:"amount,omitempty"`
	// Phase 1: Deposit index being spent (visible)
	// Phase 2: Hidden in ZK proof
	DepositIndex uint64 `protobuf:"varint,5,opt,name=deposit_index,json=depositIndex,proto3" json:"deposit_index,omitempty"`
	// Nullifier to mark this deposit as spent
	Nullifier []byte `protobuf:"bytes,6,opt,name=nullifier,proto3" json:"nullifier,omitempty"`
	// Phase 1: Signature proving ownership of the deposit
	// Phase 2: Empty (ownership proven in ZK proof)
	Signature []byte `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"`
	// Phase 2 only: ZK proof that:
	//   - Deposit exists in Merkle tree
	//   - Nullifier is correctly derived
	//   - Amount matches commitment
	ZkProof *ZKProof `protobuf:"bytes,8,opt,name=zk_proof,json=zkProof,proto3" json:"zk_proof,omitempty"`
	// Pedersen commitment to the amount being unshielded
	Commitment PedersenCommitment `protobuf:"bytes,9,opt,name=commitment,proto3" json:"commitment"`
}

func (m *MsgUnshield) Reset()         { *m = MsgUnshield{} }
func (m *MsgUnshield) String() string { return proto.CompactTextString(m) }
func (*MsgUnshield) ProtoMessage()    {}
func (*MsgUnshield) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{4}
}
func (m *MsgUnshield) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnshield) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnshield.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnshield) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnshield.Merge(m, src)
}
func (m *MsgUnshield) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnshield) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnshield.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnshield proto.InternalMessageInfo

func (m *MsgUnshield) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgUnshield) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUnshield) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *MsgUnshield) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *MsgUnshield) GetDepositIndex() uint64 {
	if m != nil {
		return m.DepositIndex
	}
	return 0
}

func (m *MsgUnshield) GetNullifier() []byte {
	if m != nil {
		return m.Nullifier
	}
	return nil
}

func (m *MsgUnshield) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *MsgUnshield) GetZkProof() *ZKProof {
	if m != nil {
		return m.ZkProof
	}
	return nil
}

func (m *MsgUnshield) GetCommitment() PedersenCommitment {
	if m != nil {
		return m.Commitment
	}
	return PedersenCommitment{}
}

// MsgUnshieldResponse confirms the unshield operation.
type MsgUnshieldResponse struct {
	// Amount that was unshielded and minted to recipient
	Amount types.Coin `protobuf:"bytes,1,opt,name=amount,proto3" json:"amount"`
}

func (m *MsgUnshieldResponse) Reset()         { *m = MsgUnshieldResponse{} }
func (m *MsgUnshieldResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUnshieldResponse) ProtoMessage()    {}
func (*MsgUnshieldResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{5}
}
func (m *MsgUnshieldResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnshieldResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnshieldResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnshieldResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnshieldResponse.Merge(m, src)
}
func (m *MsgUnshieldResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnshieldResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnshieldResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnshieldResponse proto.InternalMessageInfo

func (m *MsgUnshieldResponse) GetAmount() types.Coin {
	if m != nil {
		return m.Amount
	}
	return types.Coin{}
}

// MsgUpdateParams defines the message for updating module parameters.
// This message can only be executed via governance proposal.
type MsgUpdateParams struct {
	// Authority is the address that controls the module parameters.
	// Defaults to the x/gov module account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// Params defines the new parameters for the privacy module.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{6}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse is the response for MsgUpdateParams.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_64d939568c8a6248, []int{7}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgShield)(nil), "hikari.privacy.v1.MsgShield")
	proto.RegisterType((*MsgShieldResponse)(nil), "hikari.privacy.v1.MsgShieldResponse")
	proto.RegisterType((*MsgPrivateTransfer)(nil), "hikari.privacy.v1.MsgPrivateTransfer")
	proto.RegisterType((*MsgPrivateTransferResponse)(nil), "hikari.privacy.v1.MsgPrivateTransferResponse")
	proto.RegisterType((*MsgUnshield)(nil), "hikari.privacy.v1.MsgUnshield")
	proto.RegisterType((*MsgUnshieldResponse)(nil), "hikari.privacy.v1.MsgUnshieldResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "hikari.privacy.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "hikari.privacy.v1.MsgUpdateParamsResponse")
}

func init() { proto.RegisterFile("hikari/privacy/v1/tx.proto", fileDescriptor_64d939568c8a6248) }

var fileDescriptor_64d939568c8a6248 = []byte{
	// 947 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0x4f, 0x4f, 0xe3, 0x46,
	0x14, 0xc7, 0x38, 0x04, 0x18, 0x02, 0x5b, 0x5c, 0x24, 0x82, 0xb5, 0x0d, 0x6c, 0xb6, 0x20, 0x84,
	0x14, 0xbb, 0xa1, 0xed, 0x56, 0xe2, 0x50, 0x69, 0xa1, 0x87, 0xa2, 0x2d, 0x2c, 0xf5, 0x6e, 0x2f,
	0x1c, 0x1a, 0x39, 0xf6, 0xc3, 0x19, 0x11, 0xcf, 0x58, 0x9e, 0x09, 0x82, 0x3d, 0x55, 0x3d, 0xb6,
	0x97, 0x7e, 0x14, 0x0e, 0x7b, 0xea, 0x27, 0x58, 0xa9, 0x97, 0xd5, 0x9e, 0x7a, 0x69, 0x55, 0xc1,
	0x81, 0x8f, 0xd0, 0x6b, 0x35, 0x7f, 0xec, 0x84, 0xc4, 0xfc, 0xd9, 0xed, 0x25, 0xf2, 0x7b, 0xef,
	0xf7, 0x7e, 0xf3, 0xf4, 0xde, 0x6f, 0xde, 0x04, 0xd9, 0x1d, 0x7c, 0xec, 0xa7, 0xd8, 0x4d, 0x52,
	0x7c, 0xe2, 0x07, 0x67, 0xee, 0x49, 0xd3, 0xe5, 0xa7, 0x4e, 0x92, 0x52, 0x4e, 0xad, 0x79, 0x15,
	0x73, 0x74, 0xcc, 0x39, 0x69, 0xda, 0xcb, 0xa3, 0xf0, 0x2c, 0x2a, 0x73, 0xec, 0x5a, 0x01, 0xc0,
	0x4f, 0xfd, 0x98, 0xe9, 0xf8, 0x52, 0x40, 0x59, 0x4c, 0x59, 0x4b, 0x5a, 0xae, 0x32, 0x74, 0x68,
	0x51, 0x59, 0x6e, 0xcc, 0x22, 0x91, 0x16, 0xb3, 0x28, 0xe3, 0xd4, 0x81, 0xb6, 0xcf, 0xc0, 0x3d,
	0x69, 0xb6, 0x81, 0xfb, 0x4d, 0x37, 0xa0, 0x98, 0xe8, 0xf8, 0x42, 0x44, 0x23, 0xaa, 0x08, 0xc5,
	0x97, 0xf6, 0xce, 0xfb, 0x31, 0x26, 0xd4, 0x95, 0xbf, 0xca, 0x55, 0xff, 0xd5, 0x44, 0xd3, 0x7b,
	0x2c, 0x7a, 0xd1, 0xc1, 0xd0, 0x0d, 0xad, 0xcf, 0x50, 0x99, 0x01, 0x09, 0x21, 0xad, 0x1a, 0x2b,
	0xc6, 0xfa, 0xf4, 0x76, 0xf5, 0xdd, 0xeb, 0xc6, 0x82, 0xae, 0xe8, 0x69, 0x18, 0xa6, 0xc0, 0xd8,
	0x0b, 0x9e, 0x62, 0x12, 0x79, 0x1a, 0x67, 0x7d, 0x85, 0xca, 0x7e, 0x4c, 0x7b, 0x84, 0x57, 0xc7,
	0x57, 0x8c, 0xf5, 0x99, 0xcd, 0x25, 0x47, 0xc3, 0x45, 0x65, 0x8e, 0xae, 0xcc, 0xd9, 0xa1, 0x98,
	0x6c, 0x97, 0xde, 0xfc, 0xbd, 0x3c, 0xe6, 0x69, 0xb8, 0xf5, 0x3d, 0xfa, 0x88, 0x12, 0x68, 0x71,
	0x1c, 0x43, 0xcb, 0x57, 0xd4, 0x55, 0x53, 0x52, 0x3c, 0x72, 0x46, 0x9a, 0xec, 0x3c, 0x27, 0xf0,
	0x12, 0xc7, 0xa0, 0x6b, 0xd0, 0x54, 0x73, 0xf4, 0x9a, 0xd7, 0x7a, 0x86, 0x50, 0x40, 0xe3, 0x18,
	0xf3, 0x18, 0x08, 0xaf, 0x96, 0x24, 0xd9, 0x6a, 0x01, 0xd9, 0x01, 0x84, 0x90, 0x32, 0x20, 0x3b,
	0x39, 0x58, 0x13, 0x0e, 0xa4, 0x5b, 0xdf, 0xa0, 0x39, 0x20, 0x41, 0x7a, 0x96, 0x70, 0x08, 0x5b,
	0x84, 0x72, 0xa8, 0x4e, 0x48, 0xc2, 0xc5, 0x02, 0xc2, 0x7d, 0xca, 0x41, 0x53, 0xcc, 0xe6, 0x49,
	0xc2, 0xb9, 0xd5, 0xf8, 0xf9, 0xea, 0x7c, 0x43, 0xf7, 0xea, 0x97, 0xab, 0xf3, 0x8d, 0x4f, 0xb4,
	0x16, 0x4e, 0x07, 0xd5, 0x90, 0xf7, 0xbf, 0x4e, 0xd1, 0x7c, 0x6e, 0x78, 0xc0, 0x12, 0x4a, 0x18,
	0x58, 0x0b, 0x68, 0x22, 0x04, 0x42, 0x63, 0x35, 0x13, 0x4f, 0x19, 0xd6, 0x63, 0x34, 0x1b, 0x42,
	0x42, 0x19, 0xe6, 0x2d, 0x4c, 0x42, 0x38, 0x95, 0xfd, 0x2f, 0x79, 0x15, 0xed, 0xdc, 0x15, 0x3e,
	0x6b, 0x19, 0xcd, 0xc4, 0x90, 0x1e, 0x77, 0xa1, 0x95, 0x52, 0xca, 0x65, 0x7f, 0x2b, 0x1e, 0x52,
	0x2e, 0x8f, 0x52, 0x5e, 0xff, 0xcb, 0x44, 0xd6, 0x1e, 0x8b, 0x0e, 0x44, 0x31, 0x1c, 0x5e, 0xa6,
	0x3e, 0x61, 0x47, 0x90, 0x7e, 0x80, 0x0e, 0xf2, 0x22, 0xc7, 0x07, 0x8b, 0xfc, 0x1a, 0x95, 0x31,
	0x49, 0x7a, 0x5c, 0x8c, 0xd6, 0x5c, 0x9f, 0xd9, 0x5c, 0x29, 0x68, 0x5e, 0x76, 0xe8, 0xae, 0x00,
	0x66, 0x22, 0x51, 0x59, 0xd6, 0x53, 0x34, 0x49, 0x7b, 0x5c, 0x12, 0x94, 0x24, 0xc1, 0xa3, 0x5b,
	0x08, 0x9e, 0x4b, 0xa4, 0x66, 0xc8, 0xf2, 0xac, 0x2f, 0xd1, 0xd4, 0xab, 0x63, 0x71, 0xb7, 0xe8,
	0x91, 0x9e, 0xa0, 0x5d, 0xc0, 0x71, 0xf8, 0xec, 0x40, 0x20, 0xbc, 0xc9, 0x57, 0xc7, 0xf2, 0xc3,
	0x3a, 0x44, 0x56, 0xdb, 0xef, 0xfa, 0x24, 0x80, 0xd6, 0x80, 0xa6, 0xca, 0xef, 0xaf, 0xa9, 0x79,
	0x4d, 0xd3, 0x0f, 0x58, 0x4d, 0x64, 0x1e, 0x01, 0x54, 0x27, 0xef, 0x77, 0x61, 0x04, 0x76, 0xeb,
	0xc9, 0x90, 0x8e, 0xd6, 0x6e, 0xd0, 0xd1, 0xd0, 0x20, 0xeb, 0x21, 0xb2, 0x47, 0xbd, 0xb9, 0xb2,
	0x56, 0xd1, 0x9c, 0x6a, 0x93, 0x90, 0x10, 0x0e, 0x80, 0x55, 0x8d, 0x15, 0x73, 0xbd, 0xe4, 0xcd,
	0x2a, 0xef, 0xae, 0x72, 0x0e, 0xab, 0x68, 0x7c, 0x44, 0x45, 0x7f, 0x98, 0x68, 0x66, 0x8f, 0x45,
	0x3f, 0x10, 0xf6, 0xa1, 0x6b, 0xa4, 0x58, 0x3e, 0x4f, 0xd0, 0x74, 0x0a, 0x01, 0x4e, 0xb0, 0xe8,
	0xbd, 0x79, 0x07, 0x55, 0x1f, 0x6a, 0xad, 0xe5, 0x4b, 0xa9, 0x24, 0x93, 0xe6, 0xde, 0xbd, 0x6e,
	0x20, 0x9d, 0xb4, 0x4b, 0x78, 0xbe, 0x83, 0x46, 0xee, 0xd0, 0x44, 0xc1, 0x1d, 0x7a, 0x88, 0xa6,
	0x49, 0xaf, 0xdb, 0xc5, 0x47, 0x18, 0x52, 0x29, 0x80, 0x8a, 0xd7, 0x77, 0x88, 0x28, 0xc3, 0x11,
	0xf1, 0x79, 0x2f, 0x55, 0x13, 0xad, 0x78, 0x7d, 0xc7, 0x35, 0xf1, 0x4d, 0xdd, 0x5f, 0x7c, 0xd7,
	0x17, 0xd9, 0xf4, 0xff, 0x5a, 0x64, 0x5b, 0xee, 0x90, 0x74, 0x96, 0x6f, 0x90, 0x4e, 0x36, 0xbd,
	0xfa, 0x3e, 0xfa, 0x78, 0xc0, 0xcc, 0xc5, 0xd2, 0xdf, 0xf4, 0xc6, 0x7b, 0x6d, 0xfa, 0xfa, 0xef,
	0x06, 0x7a, 0x20, 0x08, 0x93, 0xd0, 0xe7, 0x70, 0x20, 0x5f, 0x3e, 0x31, 0x59, 0xbf, 0xc7, 0x3b,
	0x34, 0xc5, 0xfc, 0xec, 0x4e, 0x91, 0xf4, 0xa1, 0xa2, 0x08, 0xf5, 0x76, 0xe6, 0xcf, 0x4d, 0x41,
	0x57, 0x24, 0x20, 0x2b, 0x42, 0xc1, 0xd5, 0x05, 0xea, 0x13, 0x89, 0x46, 0x3c, 0xbe, 0xa9, 0x11,
	0x03, 0x85, 0xd6, 0x97, 0xd0, 0xe2, 0x90, 0x2b, 0x6b, 0xc8, 0xe6, 0xbf, 0xe3, 0xc8, 0xdc, 0x63,
	0x91, 0xf5, 0x1d, 0x2a, 0xeb, 0xe7, 0xf3, 0x61, 0x41, 0x35, 0xf9, 0x3e, 0xb7, 0x3f, 0xbd, 0x2d,
	0x9a, 0xb7, 0x39, 0x42, 0x0f, 0x86, 0xb7, 0xf1, 0x6a, 0x71, 0xe2, 0x10, 0xcc, 0x6e, 0xdc, 0x0b,
	0x96, 0x1f, 0xe4, 0xa1, 0xa9, 0xfc, 0xc2, 0xd6, 0x8a, 0x53, 0xb3, 0xb8, 0xbd, 0x76, 0x7b, 0x3c,
	0xe7, 0xfc, 0x11, 0x55, 0xae, 0x8d, 0xb9, 0x7e, 0x43, 0xde, 0x00, 0xc6, 0xde, 0xb8, 0x1b, 0x93,
	0xf1, 0xdb, 0x13, 0x3f, 0x5d, 0x9d, 0x6f, 0x18, 0xdb, 0xfb, 0x6f, 0x2e, 0x6a, 0xc6, 0xdb, 0x8b,
	0x9a, 0xf1, 0xcf, 0x45, 0xcd, 0xf8, 0xed, 0xb2, 0x36, 0xf6, 0xf6, 0xb2, 0x36, 0xf6, 0xe7, 0x65,
	0x6d, 0xec, 0xf0, 0x8b, 0x08, 0xf3, 0x4e, 0xaf, 0xed, 0x04, 0x34, 0x76, 0xbf, 0x95, 0xb4, 0x8d,
	0x9d, 0x8e, 0x8f, 0x89, 0xab, 0xce, 0x68, 0x04, 0xd2, 0xe8, 0x4f, 0x9c, 0x9f, 0x25, 0xc0, 0xda,
	0x65, 0xf9, 0x5f, 0xe8, 0xf3, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xea, 0xfb, 0xf1, 0x6f, 0xfa,
	0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// Shield moves coins from public balance to the privacy pool.
	Shield(ctx context.Context, in *MsgShield, opts ...grpc.CallOption) (*MsgShieldResponse, error)
	// PrivateTransfer transfers coins within the privacy pool.
	PrivateTransfer(ctx context.Context, in *MsgPrivateTransfer, opts ...grpc.CallOption) (*MsgPrivateTransferResponse, error)
	// Unshield moves coins from the privacy pool back to public balance.
	Unshield(ctx context.Context, in *MsgUnshield, opts ...grpc.CallOption) (*MsgUnshieldResponse, error)
	// UpdateParams updates the module parameters.
	// Authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) Shield(ctx context.Context, in *MsgShield, opts ...grpc.CallOption) (*MsgShieldResponse, error) {
	out := new(MsgShieldResponse)
	err := c.cc.Invoke(ctx, "/hikari.privacy.v1.Msg/Shield", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) PrivateTransfer(ctx context.Context, in *MsgPrivateTransfer, opts ...grpc.CallOption) (*MsgPrivateTransferResponse, error) {
	out := new(MsgPrivateTransferResponse)
	err := c.cc.Invoke(ctx, "/hikari.privacy.v1.Msg/PrivateTransfer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) Unshield(ctx context.Context, in *MsgUnshield, opts ...grpc.CallOption) (*MsgUnshieldResponse, error) {
	out := new(MsgUnshieldResponse)
	err := c.cc.Invoke(ctx, "/hikari.privacy.v1.Msg/Unshield", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/hikari.privacy.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// Shield moves coins from public balance to the privacy pool.
	Shield(context.Context, *MsgShield) (*MsgShieldResponse, error)
	// PrivateTransfer transfers coins within the privacy pool.
	PrivateTransfer(context.Context, *MsgPrivateTransfer) (*MsgPrivateTransferResponse, error)
	// Unshield moves coins from the privacy pool back to public balance.
	Unshield(context.Context, *MsgUnshield) (*MsgUnshieldResponse, error)
	// UpdateParams updates the module parameters.
	// Authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) Shield(ctx context.Context, req *MsgShield) (*MsgShieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shield not implemented")
}
func (*UnimplementedMsgServer) PrivateTransfer(ctx context.Context, req *MsgPrivateTransfer) (*MsgPrivateTransferResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrivateTransfer not implemented")
}
func (*UnimplementedMsgServer) Unshield(ctx context.Context, req *MsgUnshield) (*MsgUnshieldResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unshield not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_Shield_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgShield)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Shield(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hikari.privacy.v1.Msg/Shield",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Shield(ctx, req.(*MsgShield))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_PrivateTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPrivateTransfer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).PrivateTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hikari.privacy.v1.Msg/PrivateTransfer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).PrivateTransfer(ctx, req.(*MsgPrivateTransfer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_Unshield_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUnshield)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).Unshield(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hikari.privacy.v1.Msg/Unshield",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).Unshield(ctx, req.(*MsgUnshield))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/hikari.privacy.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "hikari.privacy.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Shield",
			Handler:    _Msg_Shield_Handler,
		},
		{
			MethodName: "PrivateTransfer",
			Handler:    _Msg_PrivateTransfer_Handler,
		},
		{
			MethodName: "Unshield",
			Handler:    _Msg_Unshield_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hikari/privacy/v1/tx.proto",
}

func (m *MsgShield) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgShield) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgShield) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EncryptedNote.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.OneTimeAddress.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgShieldResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgShieldResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgShieldResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.DepositIndex != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DepositIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPrivateTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPrivateTransfer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPrivateTransfer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Fee.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.BalanceCommitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.ZkProof != nil {
		{
			size, err := m.ZkProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Outputs) > 0 {
		for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Inputs) > 0 {
		for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPrivateTransferResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPrivateTransferResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPrivateTransferResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MerkleRoot) > 0 {
		i -= len(m.MerkleRoot)
		copy(dAtA[i:], m.MerkleRoot)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MerkleRoot)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OutputIndices) > 0 {
		dAtA9 := make([]byte, len(m.OutputIndices)*10)
		var j8 int
		for _, num := range m.OutputIndices {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTx(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnshield) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnshield) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnshield) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Commitment.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.ZkProof != nil {
		{
			size, err := m.ZkProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Nullifier) > 0 {
		i -= len(m.Nullifier)
		copy(dAtA[i:], m.Nullifier)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Nullifier)))
		i--
		dAtA[i] = 0x32
	}
	if m.DepositIndex != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DepositIndex))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnshieldResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnshieldResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnshieldResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgShield) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.OneTimeAddress.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Commitment.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.EncryptedNote.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgShieldResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DepositIndex != 0 {
		n += 1 + sovTx(uint64(m.DepositIndex))
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPrivateTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Outputs) > 0 {
		for _, e := range m.Outputs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.ZkProof != nil {
		l = m.ZkProof.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.BalanceCommitment.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Fee.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPrivateTransferResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.OutputIndices) > 0 {
		l = 0
		for _, e := range m.OutputIndices {
			l += sovTx(uint64(e))
		}
		n += 1 + sovTx(uint64(l)) + l
	}
	l = len(m.MerkleRoot)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUnshield) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DepositIndex != 0 {
		n += 1 + sovTx(uint64(m.DepositIndex))
	}
	l = len(m.Nullifier)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ZkProof != nil {
		l = m.ZkProof.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Commitment.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUnshieldResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Amount.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgShield) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgShield: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgShield: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OneTimeAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.OneTimeAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedNote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncryptedNote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgShieldResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgShieldResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgShieldResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositIndex", wireType)
			}
			m.DepositIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = append(m.MerkleRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.MerkleRoot == nil {
				m.MerkleRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPrivateTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPrivateTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPrivateTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, TransferInput{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Outputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Outputs = append(m.Outputs, TransferOutput{})
			if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZkProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZkProof == nil {
				m.ZkProof = &ZKProof{}
			}
			if err := m.ZkProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BalanceCommitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BalanceCommitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Fee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPrivateTransferResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPrivateTransferResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPrivateTransferResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputIndices = append(m.OutputIndices, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTx
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTx
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTx
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutputIndices) == 0 {
					m.OutputIndices = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTx
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputIndices = append(m.OutputIndices, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputIndices", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MerkleRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MerkleRoot = append(m.MerkleRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.MerkleRoot == nil {
				m.MerkleRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnshield) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnshield: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnshield: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DepositIndex", wireType)
			}
			m.DepositIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DepositIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nullifier = append(m.Nullifier[:0], dAtA[iNdEx:postIndex]...)
			if m.Nullifier == nil {
				m.Nullifier = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZkProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZkProof == nil {
				m.ZkProof = &ZKProof{}
			}
			if err := m.ZkProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commitment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commitment.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnshieldResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnshieldResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnshieldResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
